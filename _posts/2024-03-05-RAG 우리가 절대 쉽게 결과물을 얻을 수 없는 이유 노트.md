---
layout: post
title: RAG 우리가 절대 쉽게 결과물을 얻을 수 없는 이유 노트
date: 2024-03-05 22:42 +0900
categories:
  - Deep-Learning
  - NLP
tags: 
math: true
---

### 목차
1. 지난 1년간 (2023) 6개 기업의 10여개 프로젝트에서 얻은 RAG 경험담
2. 마주한 도전들
3. 실패 사례, 극복 시도
4. Vector Store, Prompt Engineering, LLM Fine-tuning

### 용어정리 
RAG: Retrieval Augmented Generation




### RAG 프로세스

자체 정의한 RAG 프로세스 과정
#### 1. 전처리 작업

1. Load Document: 처리할 문서를 시스템에 불러옵
2. Chunk(Split): 문서를 더 작고 관리하기 쉬운 조각으로 나눈다(llm은 한번에 읽을 수 있는 단어는 few thousands 이기 때문)
3. Embedding: 이 조각들을 내용의 본질을 포착하는 숫자 표현으로 변환
4. Store: 임베딩들을 데이터베이스에 저장

![](https://i.imgur.com/yUgGrWZ.png)

#### 2. 서비스 단계에서 이뤄지는 작업
- llm 서비스 구동중인 상태에서 이뤄지는 작업

1. 유저 질문을 받아 Embedding 처리
2. Retrieve(발췌) 
	- 실시간으로 이루어짐
3. 프롬프트 엔지니어링후 LLM에 전달
4. output

![](https://i.imgur.com/6nPNirw.png)

### 문서 전처리

#### 모듈
1. Document Loader: 문서 로드
	- Langchain에서 150가지 loader 지원 
2. Text Splitter: 분할 전략
	- 10 가지 알고리즘 지원
3. Embedding: 임베딩
	- Langchain + HuggingFace
4. Vector Store: Vector DB
	- Sementic Search를 위해 RAG에서는 주로 VectorDB사용
	- LangChain에서 80가지 지원
5. Retrievers: Vector DB 검색기
	- 50가지 지원

**강의 목적**: 위 내용을 조합하여 3억개 이상의 조합 발생 → 모든 상황 테스트 불가능 → pipeline 구성시 참고용 경험 공유


#### Document Loader(PDF)
- Excel/SCV, PDF을 주로 취급
- **보안에 유리한 PDF 형식의 문서가 많았음**


> LangChain의 강점: 통합된 Interface를 제공해 여러 모듈들을 바꿔가며 테스트해보기 용이함


Document Loader 선택시 고려사항
- 텍스트를 원형 그대로 가져오는지
	- 한글, 특수문자
- 메타데이터(metadata)의 종류
	- page_content
	- 페이지번호(page)
	- 표, 차트, 문서의 coordinates(좌표), 속성(Title, Table, Image, Text)
- 속도

> 속도 vs 다양한 메타데이터 제공여부가 관건이 될것 같다





